---
title: 程序基本结构
date: 2026-01-23
category: java
---

> 本文从「程序的基本结构」出发，解释为什么 **Java 必须有明确入口**，以及它与 **TS / Node.js 的执行模型** 在设计哲学上的根本差异。

---

## 什么是「程序结构」

从最抽象的层面看，一个程序至少要回答三个问题：

1. **从哪里开始执行？**（入口）
2. **代码如何组织？**（结构单元）
3. **依赖如何生效？**（加载 / 初始化 / 执行）

不同语言，对这三个问题的回答完全不同。

---

### TS / Node.js 的程序结构：文件即入口

```text
文件（可执行）
↓
import 递归加载
↓
模块初始化即执行
```

示例：

```ts
// index.ts
import './app'
```

关键特征：

- 文件是 **可执行单元**
- 顶层代码天然可运行
- `import` = 加载 + 执行
- 应用是一个 **文件依赖图**

> 执行一个文件，意味着执行整个依赖树。

---

### Java 的程序结构：进程 + 唯一入口

```text
进程启动
↓
加载某个类
↓
调用 main 方法
↓
程序开始执行
```

示例：

```java
public class App {
    public static void main(String[] args) {
        // 程序从这里开始
    }
}
```

关键特征：

- **类是类型单元，不是执行单元**
- Java 文件不能有顶层可执行语句
- `import` 只是命名空间引用，不触发执行
- 整个应用只有一个明确入口

> Java 的应用不是「文件图」，而是「进程 + 入口」。

---

## Q1: 那 Java 11 为什么又支持「无 main 单文件执行」？

```java
System.out.println("Hello");
```

```bash
java Hello.java
```

这并不是 Java 执行模型的改变，而是一个**受控的语法糖**：

- 只针对 **单一源文件**
- JVM 在内部生成隐式类 + 隐式 `main`
- 不进入 classpath / module-path
- 不能作为工程入口

它的定位是：

- 教学
- demo
- 脚本式工具

> 本质是 **REPL / script 模式**，不是应用模型。

---

## Q2: 为什么 Java 直到现在都没有“顶层代码”？

因为 Java 的核心目标不是“执行方便”，而是

- 强类型
- 可静态分析
- 可预测启动
- 可长期维护

如果允许顶层代码：

```java
// 假设存在
connectDB();
initCache();
```

会直接导致：

- 执行顺序依赖文件加载顺序
- 副作用难以追踪
- 类加载时机不可控
- AOT / JIT / 安全分析复杂化

Java 的选择是：

> **所有执行，必须显式发生在方法里。**

---

## Q3: Spring Boot 是如何“模拟” Node 启动体验的？

Spring Boot 的启动类：

```java
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

它做了什么：

1. 用一个极薄的 `main` 作为 JVM 入口
2. 在 `run` 内部接管控制权
3. 扫描 classpath
4. 构建依赖图（IoC 容器）
5. 通过生命周期回调模拟“模块初始化”

效果上：

- 看起来像 Node 的 `import → 执行`
- 实际仍严格遵守 Java 的入口模型

> Spring Boot 是 **框架级模拟**，不是语言级能力。

---

## Q4: 如果 Java 真的支持「模块级执行」，会发生什么？

假设：

```java
import com.xxx.A; // 自动执行 A
```

会直接破坏：

### 1. 启动确定性

- 多入口
- 顺序依赖隐式化

### 2. 可维护性

- 副作用分散在 import 中
- 重构极其危险

### 3. 工程能力

- 静态分析困难
- 编译期完整性丧失
- 类加载语义混乱

### 4. JVM 生态

- 框架无法控制生命周期
- AOT / GraalVM 成本暴涨

> Java 的工程生态，会整体失效。

---

## 总结：两种完全不同的心智模型

一句话对比：

- **TS / Node**：
  - 文件是执行单元
  - 应用是文件图
  - import = 执行

- **Java**：
  - 类是类型单元
  - 应用是进程 + 唯一入口
  - 执行必须显式发生

Java 11+ 的「无 main」：

- 降低入门门槛
- 没有改变程序结构哲学

> 理解这一点，基本就理解了 Java 为什么是今天这个样子。
