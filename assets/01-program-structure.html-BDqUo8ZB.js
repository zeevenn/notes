import{_ as n,c as s,e,o as l}from"./app-BMk1V0Kr.js";const i={};function t(o,a){return l(),s("div",null,[...a[0]||(a[0]=[e(`<blockquote><p>本文从「程序的基本结构」出发，解释为什么 <strong>Java 必须有明确入口</strong>，以及它与 <strong>TS / Node.js 的执行模型</strong> 在设计哲学上的根本差异。</p></blockquote><hr><h2 id="什么是「程序结构」" tabindex="-1"><a class="header-anchor" href="#什么是「程序结构」"><span>什么是「程序结构」</span></a></h2><p>从最抽象的层面看，一个程序至少要回答三个问题：</p><ol><li><strong>从哪里开始执行？</strong>（入口）</li><li><strong>代码如何组织？</strong>（结构单元）</li><li><strong>依赖如何生效？</strong>（加载 / 初始化 / 执行）</li></ol><p>不同语言，对这三个问题的回答完全不同。</p><hr><h3 id="ts-node-js-的程序结构-文件即入口" tabindex="-1"><a class="header-anchor" href="#ts-node-js-的程序结构-文件即入口"><span>TS / Node.js 的程序结构：文件即入口</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>文件（可执行）
↓
import 递归加载
↓
模块初始化即执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token comment">// index.ts</span>
<span class="token keyword">import</span> <span class="token string">&#39;./app&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>关键特征：</p><ul><li>文件是 <strong>可执行单元</strong></li><li>顶层代码天然可运行</li><li><code>import</code> = 加载 + 执行</li><li>应用是一个 <strong>文件依赖图</strong></li></ul><blockquote><p>执行一个文件，意味着执行整个依赖树。</p></blockquote><hr><h3 id="java-的程序结构-进程-唯一入口" tabindex="-1"><a class="header-anchor" href="#java-的程序结构-进程-唯一入口"><span>Java 的程序结构：进程 + 唯一入口</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>进程启动
↓
加载某个类
↓
调用 main 方法
↓
程序开始执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 程序从这里开始</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键特征：</p><ul><li><strong>类是类型单元，不是执行单元</strong></li><li>Java 文件不能有顶层可执行语句</li><li><code>import</code> 只是命名空间引用，不触发执行</li><li>整个应用只有一个明确入口</li></ul><blockquote><p>Java 的应用不是「文件图」，而是「进程 + 入口」。</p></blockquote><hr><h2 id="q1-那-java-11-为什么又支持「无-main-单文件执行」" tabindex="-1"><a class="header-anchor" href="#q1-那-java-11-为什么又支持「无-main-单文件执行」"><span>Q1: 那 Java 11 为什么又支持「无 main 单文件执行」？</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">java</span> Hello.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这并不是 Java 执行模型的改变，而是一个<strong>受控的语法糖</strong>：</p><ul><li>只针对 <strong>单一源文件</strong></li><li>JVM 在内部生成隐式类 + 隐式 <code>main</code></li><li>不进入 classpath / module-path</li><li>不能作为工程入口</li></ul><p>它的定位是：</p><ul><li>教学</li><li>demo</li><li>脚本式工具</li></ul><blockquote><p>本质是 <strong>REPL / script 模式</strong>，不是应用模型。</p></blockquote><hr><h2 id="q2-为什么-java-直到现在都没有「顶层代码」" tabindex="-1"><a class="header-anchor" href="#q2-为什么-java-直到现在都没有「顶层代码」"><span>Q2: 为什么 Java 直到现在都没有「顶层代码」？</span></a></h2><p>因为 Java 的核心目标不是「执行方便」，而是</p><ul><li>强类型</li><li>可静态分析</li><li>可预测启动</li><li>可长期维护</li></ul><p>如果允许顶层代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 假设存在</span>
<span class="token function">connectDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">initCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会直接导致：</p><ul><li>执行顺序依赖文件加载顺序</li><li>副作用难以追踪</li><li>类加载时机不可控</li><li>AOT / JIT / 安全分析复杂化</li></ul><p>Java 的选择是：</p><blockquote><p><strong>所有执行，必须显式发生在方法里。</strong></p></blockquote><hr><h2 id="q3-spring-boot-是如何「模拟」-node-启动体验的" tabindex="-1"><a class="header-anchor" href="#q3-spring-boot-是如何「模拟」-node-启动体验的"><span>Q3: Spring Boot 是如何「模拟」 Node 启动体验的？</span></a></h2><p>Spring Boot 的启动类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">App</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它做了什么：</p><ol><li>用一个极薄的 <code>main</code> 作为 JVM 入口</li><li>在 <code>run</code> 内部接管控制权</li><li>扫描 classpath</li><li>构建依赖图（IoC 容器）</li><li>通过生命周期回调模拟「模块初始化」</li></ol><p>效果上：</p><ul><li>看起来像 Node 的 <code>import → 执行</code></li><li>实际仍严格遵守 Java 的入口模型</li></ul><blockquote><p>Spring Boot 是 <strong>框架级模拟</strong>，不是语言级能力。</p></blockquote><hr><h2 id="q4-如果-java-真的支持「模块级执行」-会发生什么" tabindex="-1"><a class="header-anchor" href="#q4-如果-java-真的支持「模块级执行」-会发生什么"><span>Q4: 如果 Java 真的支持「模块级执行」，会发生什么？</span></a></h2><p>假设：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span></span><span class="token class-name">A</span></span><span class="token punctuation">;</span> <span class="token comment">// 自动执行 A</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会直接破坏：</p><h3 id="_1-启动确定性" tabindex="-1"><a class="header-anchor" href="#_1-启动确定性"><span>1. 启动确定性</span></a></h3><ul><li>多入口</li><li>顺序依赖隐式化</li></ul><h3 id="_2-可维护性" tabindex="-1"><a class="header-anchor" href="#_2-可维护性"><span>2. 可维护性</span></a></h3><ul><li>副作用分散在 import 中</li><li>重构极其危险</li></ul><h3 id="_3-工程能力" tabindex="-1"><a class="header-anchor" href="#_3-工程能力"><span>3. 工程能力</span></a></h3><ul><li>静态分析困难</li><li>编译期完整性丧失</li><li>类加载语义混乱</li></ul><h3 id="_4-jvm-生态" tabindex="-1"><a class="header-anchor" href="#_4-jvm-生态"><span>4. JVM 生态</span></a></h3><ul><li>框架无法控制生命周期</li><li>AOT / GraalVM 成本暴涨</li></ul><blockquote><p>Java 的工程生态，会整体失效。</p></blockquote><hr><h2 id="总结-两种完全不同的心智模型" tabindex="-1"><a class="header-anchor" href="#总结-两种完全不同的心智模型"><span>总结：两种完全不同的心智模型</span></a></h2><p>一句话对比：</p><ul><li><p><strong>TS / Node</strong>：</p><ul><li>文件是执行单元</li><li>应用是文件图</li><li>import = 执行</li></ul></li><li><p><strong>Java</strong>：</p><ul><li>类是类型单元</li><li>应用是进程 + 唯一入口</li><li>执行必须显式发生</li></ul></li></ul><p>Java 11+ 的「无 main」：</p><ul><li>降低入门门槛</li><li>没有改变程序结构哲学</li></ul><blockquote><p>理解这一点，基本就理解了 Java 为什么是今天这个样子。</p></blockquote>`,71)])])}const c=n(i,[["render",t],["__file","01-program-structure.html.vue"]]),r=JSON.parse('{"path":"/backend/java/language/01-program-structure.html","title":"程序基本结构","lang":"zh-CN","frontmatter":{"title":"程序基本结构","date":"2026-01-23T00:00:00.000Z","category":"java","description":" 本文从「程序的基本结构」出发，解释为什么 Java 必须有明确入口，以及它与 TS / Node.js 的执行模型 在设计哲学上的根本差异。 什么是「程序结构」 从最抽象的层面看，一个程序至少要回答三个问题： 从哪里开始执行？（入口） 代码如何组织？（结构单元） 依赖如何生效？（加载 / 初始化 / 执行） 不同语言，对这三个问题的回答完全不同。 T...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/backend/java/language/01-program-structure.html"}],["meta",{"property":"og:title","content":"程序基本结构"}],["meta",{"property":"og:description","content":" 本文从「程序的基本结构」出发，解释为什么 Java 必须有明确入口，以及它与 TS / Node.js 的执行模型 在设计哲学上的根本差异。 什么是「程序结构」 从最抽象的层面看，一个程序至少要回答三个问题： 从哪里开始执行？（入口） 代码如何组织？（结构单元） 依赖如何生效？（加载 / 初始化 / 执行） 不同语言，对这三个问题的回答完全不同。 T..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-24T08:25:49.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:published_time","content":"2026-01-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-24T08:25:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"程序基本结构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-23T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-24T08:25:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 什么是「程序结构」","slug":"什么是「程序结构」","link":"#什么是「程序结构」","children":[{"level":3,"title":"1.1 TS / Node.js 的程序结构：文件即入口","slug":"ts-node-js-的程序结构-文件即入口","link":"#ts-node-js-的程序结构-文件即入口","children":[]},{"level":3,"title":"1.2 Java 的程序结构：进程 + 唯一入口","slug":"java-的程序结构-进程-唯一入口","link":"#java-的程序结构-进程-唯一入口","children":[]}]},{"level":2,"title":"2 Q1: 那 Java 11 为什么又支持「无 main 单文件执行」？","slug":"q1-那-java-11-为什么又支持「无-main-单文件执行」","link":"#q1-那-java-11-为什么又支持「无-main-单文件执行」","children":[]},{"level":2,"title":"3 Q2: 为什么 Java 直到现在都没有「顶层代码」？","slug":"q2-为什么-java-直到现在都没有「顶层代码」","link":"#q2-为什么-java-直到现在都没有「顶层代码」","children":[]},{"level":2,"title":"4 Q3: Spring Boot 是如何「模拟」 Node 启动体验的？","slug":"q3-spring-boot-是如何「模拟」-node-启动体验的","link":"#q3-spring-boot-是如何「模拟」-node-启动体验的","children":[]},{"level":2,"title":"5 Q4: 如果 Java 真的支持「模块级执行」，会发生什么？","slug":"q4-如果-java-真的支持「模块级执行」-会发生什么","link":"#q4-如果-java-真的支持「模块级执行」-会发生什么","children":[{"level":3,"title":"5.1 1. 启动确定性","slug":"_1-启动确定性","link":"#_1-启动确定性","children":[]},{"level":3,"title":"5.2 2. 可维护性","slug":"_2-可维护性","link":"#_2-可维护性","children":[]},{"level":3,"title":"5.3 3. 工程能力","slug":"_3-工程能力","link":"#_3-工程能力","children":[]},{"level":3,"title":"5.4 4. JVM 生态","slug":"_4-jvm-生态","link":"#_4-jvm-生态","children":[]}]},{"level":2,"title":"6 总结：两种完全不同的心智模型","slug":"总结-两种完全不同的心智模型","link":"#总结-两种完全不同的心智模型","children":[]}],"git":{"createdTime":1769241485000,"updatedTime":1769243149000,"contributors":[{"name":"ziven","email":"contact@ziven.me","commits":2}]},"readingTime":{"minutes":3.18,"words":954},"filePathRelative":"backend/java/language/01-program-structure.md","localizedDate":"2026年1月23日","excerpt":"","autoDesc":true}');export{c as comp,r as data};
