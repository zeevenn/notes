import{_ as t,c as o,e as c,a as n,d as a,b as l,r as p,o as i}from"./app-DHENZJ-g.js";const u={},r={class:"hint-container tip"},d={href:"https://react.dev/learn/react-compiler",target:"_blank",rel:"noopener noreferrer"};function m(k,e){const s=p("ExternalLinkIcon");return i(),o("div",null,[e[5]||(e[5]=c(`<h2 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span>useMemo</span></a></h2><p><code>useMemo</code> 可以缓存一个函数的结果，避免重复计算。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>useMemo</code> 接收两个参数：</p><ul><li><code>callback</code>：一个函数，返回一个值。</li><li><code>dependencies</code>：一个数组，包含所有依赖项。当依赖项发生变化时，<code>callback</code> 函数会重新执行。</li></ul><p><code>useMemo</code> 会返回一个 memoized 值，当依赖项发生变化时，<code>callback</code> 函数会重新执行，并返回新的值。</p><p>大部分情况下，React Compiler 会自动优化性能，只有在计算过程耗时较长导致交互明显卡顿的情况下，才有可能需要使用 <code>useMemo</code>。</p><p>当你需要缓存一个函数时，可以这样使用：</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedFunction <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;memoized function&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缓存函数的情况非常常见，因此 react 提供了 <code>useCallback</code> 钩子来避免嵌套。</p><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h2><p><code>useCallback</code> 可以缓存一个函数，避免重复创建。<code>useCallback</code> 接收两个参数：</p><ul><li><code>callback</code>：一个函数，返回一个值。</li><li><code>dependencies</code>：一个数组，包含所有依赖项。当依赖项发生变化时，<code>callback</code> 函数会重新执行。</li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedFunction <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;memoized function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="memo" tabindex="-1"><a class="header-anchor" href="#memo"><span>memo</span></a></h2><p><code>memo</code> 可以缓存一个组件，避免重复渲染。<code>memo</code> 接收两个参数：</p><ul><li><code>component</code>：一个组件，返回一个值。</li><li><code>arePropsEqual</code>：可选值，一个函数，接收两个参数，<code>prevProps</code> 和 <code>nextProps</code>，当 <code>prevProps</code> 和 <code>nextProps</code> 相等时，组件不会重新渲染，通常情况下，你不需要手动进行比较，默认情况下，<code>memo</code> 会使用 <code>Object.is</code> 进行比较。</li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> MemoizedComponent <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span>SomeComponent<span class="token punctuation">,</span> arePropsEqual<span class="token operator">?</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,18)),n("div",r,[e[4]||(e[4]=n("p",{class:"hint-container-title"},"提示",-1)),n("p",null,[e[1]||(e[1]=a("React 通常在不进行优化的情况下也足够快，但有时你需要手动 memorize 组件和值，以保持应用程序的响应速度。手动记忆化容易出错，还会增加额外的代码维护工作。",-1)),e[2]||(e[2]=n("br",null,null,-1)),n("a",d,[e[0]||(e[0]=a("React Compiler",-1)),l(s)]),e[3]||(e[3]=a(" 会在构建时自动优化 React 应用程序，但目前处于实验阶段，且在 React 19 才得到更好支持。",-1))])])])}const v=t(u,[["render",m],["__file","14-useMemo-useCallback-memo.html.vue"]]),g=JSON.parse('{"path":"/frontend/framework/react/14-useMemo-useCallback-memo.html","title":"useMemo & useCallback & memo","lang":"zh-CN","frontmatter":{"title":"useMemo & useCallback & memo","tag":["react","hooks"],"description":"useMemo useMemo 可以缓存一个函数的结果，避免重复计算。 useMemo 接收两个参数： callback：一个函数，返回一个值。 dependencies：一个数组，包含所有依赖项。当依赖项发生变化时，callback 函数会重新执行。 useMemo 会返回一个 memoized 值，当依赖项发生变化时，callback 函数会重新执...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/framework/react/14-useMemo-useCallback-memo.html"}],["meta",{"property":"og:title","content":"useMemo & useCallback & memo"}],["meta",{"property":"og:description","content":"useMemo useMemo 可以缓存一个函数的结果，避免重复计算。 useMemo 接收两个参数： callback：一个函数，返回一个值。 dependencies：一个数组，包含所有依赖项。当依赖项发生变化时，callback 函数会重新执行。 useMemo 会返回一个 memoized 值，当依赖项发生变化时，callback 函数会重新执..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-05T09:11:09.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"hooks"}],["meta",{"property":"article:modified_time","content":"2025-09-05T09:11:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"useMemo & useCallback & memo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-05T09:11:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 useMemo","slug":"usememo","link":"#usememo","children":[]},{"level":2,"title":"2 useCallback","slug":"usecallback","link":"#usecallback","children":[]},{"level":2,"title":"3 memo","slug":"memo","link":"#memo","children":[]}],"git":{"createdTime":1757063469000,"updatedTime":1757063469000,"contributors":[{"name":"Ziven","email":"contact@ziven.me","commits":2}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"frontend/framework/react/14-useMemo-useCallback-memo.md","localizedDate":"2025年9月5日","excerpt":"","autoDesc":true}');export{v as comp,g as data};
