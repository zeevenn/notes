import{_ as i,c as a,e as n,o as t}from"./app-CQvbks3D.js";const l={};function s(r,e){return t(),a("div",null,[...e[0]||(e[0]=[n(`<h2 id="what-is-microservices" tabindex="-1"><a class="header-anchor" href="#what-is-microservices"><span>What is Microservices?</span></a></h2><ul><li>将不同服务拆分为独立的微服务，每个微服务专注于特定的业务功能。</li><li>单个服务拥有完整的中间件、路由和数据库支持。</li><li>每个服务拥有自己的数据库，确保松耦合和独立的数据管理。</li></ul><h2 id="why-database-per-service" tabindex="-1"><a class="header-anchor" href="#why-database-per-service"><span>Why database per service?</span></a></h2><ul><li>每个服务需要独立于其他服务，避免单点故障</li><li>数据库结构可能随时变化</li><li>不同服务可能有不同的数据访问模式和需求（SQL、NoSQL等）</li></ul><h2 id="data-management-between-services" tabindex="-1"><a class="header-anchor" href="#data-management-between-services"><span>Data management between services</span></a></h2><h3 id="sync-communication" tabindex="-1"><a class="header-anchor" href="#sync-communication"><span>Sync communication</span></a></h3><p>服务之间的同步通信通常通过 HTTP/REST 或 gRPC 实现。调用方发出请求后，必须等待被调用服务返回结果，流程才继续。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Service A  →  Service B
   |            |
   |----req----&gt;|
   |&lt;---resp----|
   |
继续执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Pros:</p><ul><li>简单直观：请求-响应模型易于理解和实现。</li><li>实时性强：适用于查询类请求、强一致性场景、需要即时反馈的场景。</li></ul><p>Cons:</p><ul><li>强耦合：若一个服务不可用，可能导致整个请求失败。</li><li>延迟放大：整个请求响应时间取决于依赖服务的最慢响应时间。</li></ul><h3 id="async-communication" tabindex="-1"><a class="header-anchor" href="#async-communication"><span>Async communication</span></a></h3><p>服务之间通过事件驱动（EventBus）的方式进行异步通信，通常使用消息队列（如 RabbitMQ、Kafka）实现。调用方把事情「交出去」后，不等待结果，立刻返回；后续处理通过消息或事件完成。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Service A  →  MQ  →  Service B
   |
   |（立即返回）
   |
继续执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="用户下单场景" tabindex="-1"><a class="header-anchor" href="#用户下单场景"><span>用户下单场景</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>1. Order Service：创建订单（sync）
2. 发消息：OrderCreated（async）
3. Inventory / Coupon / Notification 各自消费

- 只关心：订单创建成功了吗？
- 不关心：库存具体什么时候扣，短信什么时候发
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="查询视图场景" tabindex="-1"><a class="header-anchor" href="#查询视图场景"><span>查询视图场景</span></a></h4><p>服务职责：</p><ul><li>A：User Service（用户注册，事实源）</li><li>B：Product Service（商品事实源）</li><li>C：Order Service（订单事实源）</li><li>D：UserOrderQuery Service（查询视图）</li></ul><p>关键点：</p><ul><li>A / B / C 只负责写自己的事实</li><li>D 不产生事实，只维护查询视图</li></ul><p>Async 方案的真实工作流</p><ul><li><p>写路径（Command）</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>User 注册 → A 写库 → UserCreated
下单 → C 写库 → OrderCreated
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>事件流</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>UserCreated  ─┐
OrderCreated ─┼&gt; Event Bus → D
ProductUpdated┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>D 服务内部</p><ul><li>订阅事件</li><li>冗余存储必要字段</li><li>更新自己的 read DB</li></ul></li><li><p>读路径（Query）</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Client → D → 本地 DB → 返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h4 id="pros-cons" tabindex="-1"><a class="header-anchor" href="#pros-cons"><span>Pros &amp; Cons</span></a></h4><p>Pros:</p><ul><li>松耦合：服务之间通过消息传递，降低依赖关系。</li><li>高可用性：即使某个服务不可用，消息可以在队列中等待处理。</li><li>弹性伸缩：可以根据消息量动态调整消费者数量。</li></ul><p>Cons:</p><ul><li>复杂性增加：需要处理消息的持久化、重复消费等问题。</li><li>数据冗余：需要在多个服务中维护冗余数据，增加存储和同步复杂度。</li><li>最终一致性：数据一致性可能会有延迟，适用于对实时性要求不高的场景。</li></ul>`,29)])])}const c=i(l,[["render",s],["__file","01-fundamental-ideas.html.vue"]]),o=JSON.parse('{"path":"/backend/microservice/01-fundamental-ideas.html","title":"Fundamental Ideas Around Microservices","lang":"zh-CN","frontmatter":{"title":"Fundamental Ideas Around Microservices","date":"2026-01-15T00:00:00.000Z","category":["microservice"],"description":"What is Microservices? 将不同服务拆分为独立的微服务，每个微服务专注于特定的业务功能。 单个服务拥有完整的中间件、路由和数据库支持。 每个服务拥有自己的数据库，确保松耦合和独立的数据管理。 Why database per service? 每个服务需要独立于其他服务，避免单点故障 数据库结构可能随时变化 不同服务可能有不同的数据...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/backend/microservice/01-fundamental-ideas.html"}],["meta",{"property":"og:title","content":"Fundamental Ideas Around Microservices"}],["meta",{"property":"og:description","content":"What is Microservices? 将不同服务拆分为独立的微服务，每个微服务专注于特定的业务功能。 单个服务拥有完整的中间件、路由和数据库支持。 每个服务拥有自己的数据库，确保松耦合和独立的数据管理。 Why database per service? 每个服务需要独立于其他服务，避免单点故障 数据库结构可能随时变化 不同服务可能有不同的数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-19T02:54:47.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:published_time","content":"2026-01-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-19T02:54:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Fundamental Ideas Around Microservices\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-15T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-19T02:54:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 What is Microservices?","slug":"what-is-microservices","link":"#what-is-microservices","children":[]},{"level":2,"title":"2 Why database per service?","slug":"why-database-per-service","link":"#why-database-per-service","children":[]},{"level":2,"title":"3 Data management between services","slug":"data-management-between-services","link":"#data-management-between-services","children":[{"level":3,"title":"3.1 Sync communication","slug":"sync-communication","link":"#sync-communication","children":[]},{"level":3,"title":"3.2 Async communication","slug":"async-communication","link":"#async-communication","children":[{"level":4,"title":"3.2.1 用户下单场景","slug":"用户下单场景","link":"#用户下单场景","children":[]},{"level":4,"title":"3.2.2 查询视图场景","slug":"查询视图场景","link":"#查询视图场景","children":[]},{"level":4,"title":"3.2.3 Pros & Cons","slug":"pros-cons","link":"#pros-cons","children":[]}]}]}],"git":{"createdTime":1768791287000,"updatedTime":1768791287000,"contributors":[{"name":"ziven","email":"contact@ziven.me","commits":1}]},"readingTime":{"minutes":2.43,"words":728},"filePathRelative":"backend/microservice/01-fundamental-ideas.md","localizedDate":"2026年1月15日","excerpt":"","autoDesc":true}');export{c as comp,o as data};
